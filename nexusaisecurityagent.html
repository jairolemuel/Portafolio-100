<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS AI Security Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            overflow-x: hidden;
            position: relative;
        }

        /* Background Particle Animations */
        .particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ff00;
            border-radius: 50%;
            animation: particleMove 10s linear infinite;
        }

        @keyframes particleMove {
            0% {
                transform: translateY(100vh) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) translateX(100px);
                opacity: 0;
            }
        }

        /* Animated Data Lines */
        .data-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .data-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: dataFlow 3s linear infinite;
        }

        @keyframes dataFlow {
            0% {
                width: 0%;
                left: 0;
            }
            50% {
                width: 100%;
                left: 0;
            }
            100% {
                width: 0%;
                left: 100%;
            }
        }

        /* Red Alert Mode */
        body.red-alert {
            animation: redAlertFlash 0.5s infinite alternate;
        }

        @keyframes redAlertFlash {
            0%, 100% { background: #0a0a0a; }
            50% { background: #4a0000; }
        }

        body.red-alert * {
            color: #ff3333 !important;
            border-color: #ff3333 !important;
            text-shadow: 0 0 5px #ff0000;
            filter: saturate(1.5);
        }
        
        body.red-alert .header h1 {
            animation: glitchEffect 0.3s infinite alternate;
        }

        @keyframes glitchEffect {
            0% { transform: translate(0); text-shadow: 0 0 5px #ff0000; }
            20% { transform: translate(-2px, 2px); text-shadow: 0 0 8px #ff0000, 0 0 12px #ff0000; }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); text-shadow: 0 0 8px #ff0000; }
            100% { transform: translate(0); text-shadow: 0 0 5px #ff0000; }
        }

        /* Main Container */
        .main-container {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            background: rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5rem;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 10px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 0 20px #00ffff; }
            100% { text-shadow: 0 0 40px #00ffff, 0 0 60px #00ffff; }
        }

        .status-bar {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px;
        }

        .status-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00ff00;
        }

        /* Left Panel */
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Console */
        .console {
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 20px;
            background: rgba(0, 255, 0, 0.05);
            height: 300px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .console h3 {
            margin-bottom: 15px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .console-output {
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .console-line {
            margin-bottom: 5px;
            opacity: 0;
            animation: fadeIn 0.5s ease-in forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Scanner */
        .scanner {
            border: 2px solid #ff6b00;
            border-radius: 10px;
            padding: 20px;
            background: rgba(255, 107, 0, 0.05);
            backdrop-filter: blur(5px);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .scanner h3 {
            margin-bottom: 15px;
            color: #ff6b00;
            text-shadow: 0 0 10px #ff6b00;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .scan-results {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
        }

        /* Right Panel */
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* AI Chat */
        .ai-chat {
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 20px;
            background: rgba(255, 0, 255, 0.05);
            backdrop-filter: blur(5px);
            height: 400px;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .ai-chat h3 {
            margin-bottom: 15px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 5px;
            animation: slideIn 0.3s ease-out;
        }

        .chat-message.user {
            background: rgba(0, 255, 0, 0.2);
            text-align: right;
        }

        .chat-message.ai {
            background: rgba(255, 0, 255, 0.2);
            text-align: left;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .chat-input {
            display: flex;
            gap: 10px;
        }

        .chat-input input {
            flex: 1;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #ff00ff;
            border-radius: 5px;
            color: #ff00ff;
            font-family: 'Courier New', monospace;
        }

        .chat-input input:focus {
            outline: none;
            box-shadow: 0 0 10px #ff00ff;
        }

        /* Visual Spectrum */
        .spectrum {
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 20px;
            background: rgba(0, 255, 0, 0.05);
            backdrop-filter: blur(5px);
            text-align: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .spectrum h3 {
            margin-bottom: 15px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }

        .spectrum-bars {
            display: flex;
            justify-content: space-around;
            align-items: end;
            height: 100px;
            margin-top: 20px;
        }

        .spectrum-bar {
            width: 8px;
            background: linear-gradient(to top, #00ff00, #00ffff);
            border-radius: 4px;
            transition: height 0.2s ease;
        }

        /* Controls */
        .controls {
            grid-column: 1 / -1;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            border: 2px solid #00ffff;
            border-radius: 25px;
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
            border-color: #ffffff;
            color: #ffffff;
        }

        .btn.danger {
            border-color: #ff0000;
            color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }

        .btn.danger:hover {
            border-color: #ff6666;
            color: #ff6666;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.3);
        }

        .btn.success {
            border-color: #00ff00;
            color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .btn.success:hover {
            border-color: #66ff66;
            color: #66ff66;
            box-shadow: 0 5px 15px rgba(0, 255, 0, 0.3);
        }

        .btn.btn-listening {
            border-color: #ff00ff; /* Color to indicate active state */
            color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
            animation: pulseListening 1.5s infinite; /* Pulse animation */
        }

        @keyframes pulseListening {
            0% { box-shadow: 0 0 15px #ff00ff; }
            50% { box-shadow: 0 0 25px #ff00ff, 0 0 35px #ff00ff; }
            100% { box-shadow: 0 0 15px #ff00ff; }
        }


        /* Additional Metrics */
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            background: rgba(0, 255, 255, 0.05);
            text-align: center;
            backdrop-filter: blur(5px);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9rem;
            color: #888;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
        }

        /* Typing animations */
        .typing-indicator {
            display: inline-block;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Panel hover effects */
        .console:hover, .scanner:hover, .ai-chat:hover, .spectrum:hover, .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="particle-container" id="particles"></div>
    <div class="data-lines" id="dataLines"></div>

    <div class="main-container">
        <div class="header">
            <h1>NEXUS AI Security Agent</h1>
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-value" id="cpuUsage">0%</div>
                    <div>CPU</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="memoryUsage">0%</div>
                    <div>RAM</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="networkActivity">0 KB/s</div>
                    <div>NETWORK</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="threatsBlocked">0</div>
                    <div>THREATS</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="currentTime">00:00:00</div>
                    <div>TIME</div>
                </div>
            </div>
        </div>

        <div class="left-panel">
            <div class="console">
                <h3>üñ•Ô∏è SECURITY TERMINAL</h3>
                <div class="console-output" id="consoleOutput"></div>
            </div>

            <div class="scanner">
                <h3>üîç ACTIVE SCANNER</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="scanProgress"></div>
                </div>
                <div id="scanStatus">Initializing scan...</div>
                <div class="scan-results" id="scanResults"></div>
            </div>

            <div class="spectrum">
                <h3>üìä NETWORK ACTIVITY</h3>
                <div class="spectrum-bars" id="spectrumBars"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="ai-chat">
                <h3>ü§ñ AI ASSISTANT</h3>
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type a command..." maxlength="100">
                    <button class="btn" onclick="sendMessage()">SEND</button>
                </div>
            </div>

            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="keystrokeSpeed">0</div>
                    <div class="metric-label">WPM</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="concentrationLevel">0%</div>
                    <div class="metric-label">CONCENTRATION</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="firewallLevel">100%</div>
                    <div class="metric-label">FIREWALL</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn success" onclick="boostFirewall()">üõ°Ô∏è BOOST FIREWALL</button>
            <button class="btn" onclick="startScan()">üîç SCAN</button>
            <button class="btn" onclick="toggleVoiceRecognition()">üé§ VOICE</button>
            <button class="btn danger" onclick="clearHistory()">üóëÔ∏è CLEAR</button>
            <button class="btn danger" onclick="triggerRedAlert()">üö® RED ALERT</button>
        </div>
    </div>

    <script>
        // Global variables
        let isVoiceActive = false;
        let redAlertActive = false;
        let scanProgress = 0;
        let firewallLevel = 100;
        let threatsBlocked = 0;
        let keystrokeCount = 0;
        let keystrokeStartTime = Date.now();
        let chatHistory = [];
        let systemLogs = [];
        let recognition; // Global variable for SpeechRecognition object

        // Initialization
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved data on startup
            loadHistory(); 
            updateSystemStats(); // To display loaded threat count
            document.getElementById('firewallLevel').textContent = `${firewallLevel}%`;

            initializeParticles();
            initializeDataLines();
            initializeSpectrum();
            startSystemMonitoring();
            startAutoScan();
            initializeChat();
            setupKeystrokeTracking();
        });

        // Create animated particles
        function initializeParticles() {
            const container = document.getElementById('particles');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 10 + 's';
                particle.style.animationDuration = (Math.random() * 10 + 5) + 's';
                container.appendChild(particle);
            }
        }

        // Create data lines
        function initializeDataLines() {
            const container = document.getElementById('dataLines');
            for (let i = 0; i < 10; i++) {
                const line = document.createElement('div');
                line.className = 'data-line';
                line.style.top = Math.random() * 100 + '%';
                line.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(line);
            }
        }

        // Initialize visual spectrum
        function initializeSpectrum() {
            const container = document.getElementById('spectrumBars');
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'spectrum-bar';
                bar.style.height = '10px';
                container.appendChild(bar);
            }
            animateSpectrum();
        }

        // Animate spectrum
        function animateSpectrum() {
            const bars = document.querySelectorAll('.spectrum-bar');
            bars.forEach(bar => {
                const height = Math.random() * 80 + 20;
                bar.style.height = height + 'px';
            });
            setTimeout(animateSpectrum, 200);
        }

        // System Monitoring
        function startSystemMonitoring() {
            setInterval(() => {
                updateSystemStats();
                updateClock();
                // Simulate concentration level (random for demo)
                document.getElementById('concentrationLevel').textContent = `${Math.floor(Math.random() * 40 + 60)}%`;
            }, 1000);
        }

        function updateSystemStats() {
            document.getElementById('cpuUsage').textContent = Math.floor(Math.random() * 100) + '%';
            document.getElementById('memoryUsage').textContent = Math.floor(Math.random() * 100) + '%';
            document.getElementById('networkActivity').textContent = Math.floor(Math.random() * 1000) + ' KB/s';
            document.getElementById('threatsBlocked').textContent = threatsBlocked;
            document.getElementById('firewallLevel').textContent = `${firewallLevel}%`; // Ensure firewall level updates
        }

        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {hour12: false});
            document.getElementById('currentTime').textContent = timeString;
        }

        // Console System
        function addConsoleLog(message, type = 'info') {
            const consoleOutput = document.getElementById('consoleOutput');
            const line = document.createElement('div');
            line.className = 'console-line';
            
            const timestamp = new Date().toLocaleTimeString('en-US', {hour12: false});
            let prefix = '';
            let color = '';

            if (type === 'error') {
                prefix = '[ERROR]';
                color = '#ff3333';
            } else if (type === 'warning') {
                prefix = '[WARN]';
                color = '#ff6b00';
            } else {
                prefix = '[INFO]';
                color = '#00ffff';
            }
            
            line.innerHTML = `<span style="color: #666;">[${timestamp}]</span> <span style="color: ${color};">${prefix}</span> ${message}`;
            consoleOutput.appendChild(line);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // Keep only the last 50 visual lines
            if (consoleOutput.children.length > 50) {
                consoleOutput.removeChild(consoleOutput.firstChild);
            }

            // Save to logs (for persistence)
            systemLogs.push({timestamp: new Date().toISOString(), type: type, message: message});
            if (systemLogs.length > 100) { // Limit the number of saved logs
                systemLogs.shift();
            }
            saveHistory();
        }

        // Auto Scan
        function startAutoScan() {
            setInterval(() => {
                if (Math.random() < 0.3) { // 30% chance every 5 seconds
                    detectThreat();
                }
            }, 5000);
            
            // Initial scan and welcome messages
            setTimeout(() => {
                addConsoleLog('NEXUS Security System initialized.');
                addConsoleLog('Scanner active - Monitoring for threats...');
                addConsoleLog('Firewall online - Protection Level: MAXIMUM');
                addAIMessage('ü§ñ NEXUS AI activated. How can I assist you?'); // Initial AI message
            }, 1000);
        }

        function detectThreat() {
            const threats = [
                'Unauthorized access attempt from IP 192.168.1.100',
                'Malware detected: Trojan.GenKryptik.xyz',
                'Suspicious activity on port 8080',
                'Brute force attempt blocked',
                'Phishing detected in incoming email',
                'Unauthorized database connection',
                'Port scan detected',
                'Ransomware successfully blocked',
                'DDoS attack detected and mitigated',
                'Vulnerability in web module exploited, patch applied'
            ];
            
            const threat = threats[Math.floor(Math.random() * threats.length)];
            addConsoleLog(`üö® THREAT DETECTED: ${threat}`, 'warning');
            threatsBlocked++;
            
            // Chance of red alert
            if (Math.random() < 0.15) { // Increase probability for demonstration
                triggerRedAlert();
            }
        }

        // Manual Scan
        function startScan() {
            if (scanProgress > 0 && scanProgress < 100) {
                addConsoleLog('Scan in progress. Please wait for the current scan to finish.', 'warning');
                return;
            }
            addConsoleLog('Initiating manual system scan...', 'info');
            scanProgress = 0;
            const progressBar = document.getElementById('scanProgress');
            const status = document.getElementById('scanStatus');
            const results = document.getElementById('scanResults');
            
            status.textContent = 'Scanning system...';
            results.innerHTML = '';
            
            const scanInterval = setInterval(() => {
                scanProgress += Math.random() * 10;
                progressBar.style.width = Math.min(scanProgress, 100) + '%';
                
                if (scanProgress >= 100) {
                    clearInterval(scanInterval);
                    completeScan();
                }
            }, 150); // Make it a bit faster
        }

        function completeScan() {
            const status = document.getElementById('scanStatus');
            const results = document.getElementById('scanResults');
            
            status.textContent = 'Scan Completed';
            
            const scanResults = [
                '‚úÖ 0 critical threats detected',
                `üîç ${Math.floor(Math.random() * 1000) + 500} files scanned`,
                'üõ°Ô∏è Firewall functioning correctly',
                'üîí Encryption system active',
                'üìä Network traffic: Normal',
                '‚ö° System performance: Optimal',
                'üåê All connections secure'
            ];
            
            results.innerHTML = scanResults.map(result => `<div>${result}</div>`).join('');
            addConsoleLog('Complete system scan finished - No threats detected', 'success');
            scanProgress = 0; // Reset progress
        }

        // AI Chat
        function initializeChat() {
            const chatInput = document.getElementById('chatInput');
            chatInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            // Display chat history on load
            const chatMessagesElem = document.getElementById('chatMessages');
            chatHistory.forEach(msg => {
                if (msg.type === 'user') {
                    _addUserMessageRaw(msg.message);
                } else {
                    _addAIMessageRaw(msg.message);
                }
            });
            chatMessagesElem.scrollTop = chatMessagesElem.scrollHeight; // Scroll to bottom
        }

        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message) {
                addUserMessage(message);
                input.value = '';
                
                // Simulate AI response
                setTimeout(() => {
                    const response = generateAIResponse(message);
                    addAIMessage(response);
                }, 1000);
            }
        }

        function addUserMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message user';
            messageDiv.innerHTML = `<strong>User:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Save to history
            chatHistory.push({type: 'user', message: message, timestamp: Date.now()});
            saveHistory();
        }

        // RAW version for loading from localStorage without typing animation or re-saving
        function _addUserMessageRaw(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message user';
            messageDiv.innerHTML = `<strong>User:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
        }

        function addAIMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message ai';
            // Add a temporary typing indicator
            messageDiv.innerHTML = `<strong>NEXUS:</strong> <span class="typing-indicator">‚ñà</span>`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Simulate typing time
            let i = 0;
            const typingSpeed = 30; // ms per character
            const displayMessage = () => {
                if (i < message.length) {
                    messageDiv.innerHTML = `<strong>NEXUS:</strong> ${message.substring(0, i+1)}<span class="typing-indicator">‚ñà</span>`;
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    i++;
                    setTimeout(displayMessage, typingSpeed);
                } else {
                    messageDiv.innerHTML = `<strong>NEXUS:</strong> ${message}`; // Remove indicator when finished
                    chatHistory.push({type: 'ai', message: message, timestamp: Date.now()});
                    saveHistory();
                }
            };
            setTimeout(displayMessage, 500); // Small delay before "typing" starts
        }

        // RAW version for loading from localStorage without typing animation or re-saving
        function _addAIMessageRaw(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message ai';
            messageDiv.innerHTML = `<strong>NEXUS:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
        }


        function generateAIResponse(message) {
            const lowerMessage = message.toLowerCase();
            
            if (lowerMessage.includes('status') || lowerMessage.includes('system status')) {
                return `üîç System operating at ${Math.floor(Math.random() * 20 + 80)}%. Firewall active. ${threatsBlocked} threats blocked today.`;
            }
            
            if (lowerMessage.includes('scan system') || lowerMessage.includes('start scan')) {
                startScan();
                return 'üîç Initiating full system scan...';
            }
            
            if (lowerMessage.includes('firewall') || lowerMessage.includes('protection level')) {
                return `üõ°Ô∏è Firewall operating at ${firewallLevel}%. Active protection against ${Math.floor(Math.random() * 1000 + 5000)} threat types.`;
            }
            
            if (lowerMessage.includes('threat') || lowerMessage.includes('danger')) {
                return `‚ö†Ô∏è Current threat level: ${Math.random() < 0.7 ? 'LOW' : 'MEDIUM'}. System monitoring ${Math.floor(Math.random() * 50 + 100)} active connections.`;
            }
            
            if (lowerMessage.includes('help') || lowerMessage.includes('commands')) {
                return 'ü§ñ Available commands: "system status", "scan system", "firewall", "threats", "clear history", "red alert". How can I assist?';
            }
            
            if (lowerMessage.includes('clear') || lowerMessage.includes('delete')) {
                return 'üóëÔ∏è Do you confirm clearing the history? Use the "CLEAR" button to proceed, or you can confirm with "yes, clear".';
            }

            if (lowerMessage.includes('yes, clear') || lowerMessage.includes('confirm clear')) {
                clearHistory();
                return 'üóëÔ∏è History and logs successfully deleted.';
            }

            if (lowerMessage.includes('red alert') || lowerMessage.includes('emergency')) {
                triggerRedAlert();
                return 'üö® RED ALERT ACTIVATED! Preparing critical defenses.';
            }
            
            // Generic responses
            const responses = [
                'üîí Analyzing request... Security protocol activated.',
                '‚ö° Processing command through advanced neural matrix.',
                'üõ°Ô∏è Verifying security clearances... Access granted.',
                'üìä Querying threat database... Information updated.',
                'ü§ñ Command recognized. Executing response protocol.',
                'üîç Scanning context of query... Optimized response.'
            ];
            
            return responses[Math.floor(Math.random() * responses.length)];
        }

        // Voice Recognition
        function toggleVoiceRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('Your browser does not support voice recognition. Please use Chrome for this feature.');
                return;
            }
            
            if (isVoiceActive) {
                stopVoiceRecognition();
            } else {
                startVoiceRecognition();
            }
        }

        function startVoiceRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition(); // Assign to global variable
            
            recognition.lang = 'en-US'; // Set language to English
            recognition.continuous = false;
            recognition.interimResults = false;
            
            recognition.onstart = function() {
                isVoiceActive = true;
                addConsoleLog('üé§ Voice recognition ACTIVE. Speak now.');
                const voiceButton = document.querySelector('.btn[onclick="toggleVoiceRecognition()"]');
                if (voiceButton) { // Ensure button exists
                    voiceButton.textContent = 'üé§ LISTENING...';
                    voiceButton.classList.add('btn-listening');
                }
            };

            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                addConsoleLog(`üé§ Voice command received: "${transcript}"`);
                document.getElementById('chatInput').value = transcript;
                sendMessage(); // Send the command to chat for AI processing.

                // Add logic for direct voice commands
                const lowerTranscript = transcript.toLowerCase();
                if (lowerTranscript.includes('scan system') || lowerTranscript.includes('start scan')) {
                    startScan();
                    addAIMessage('Order received: Initiating security scan...');
                } else if (lowerTranscript.includes('maximize firewall') || lowerTranscript.includes('activate protection')) {
                    boostFirewall();
                    addAIMessage('Firewall reinforced. Protection at maximum.');
                } else if (lowerTranscript.includes('red alert') || lowerTranscript.includes('emergency mode')) {
                    triggerRedAlert();
                    addAIMessage('RED ALERT ACTIVATED! Preparing critical defenses.');
                } else if (lowerTranscript.includes('clear console') || lowerTranscript.includes('delete logs') || lowerTranscript.includes('clear all')) {
                    clearHistory(); 
                    addAIMessage('History and console logs deleted.');
                } else {
                    // If not a direct command, AI will respond via sendMessage()
                }
            };

            recognition.onerror = function(event) {
                addConsoleLog(`‚ùå Voice recognition error: ${event.error}`, 'error');
                stopVoiceRecognition();
            };

            recognition.onend = function() {
                stopVoiceRecognition();
            };

            try {
                recognition.start();
            } catch (e) {
                addConsoleLog('üé§ Voice recognition is already active or there was a problem starting it.', 'error');
                stopVoiceRecognition(); // Ensure visual state resets
            }
        }

        function stopVoiceRecognition() {
            if (recognition && isVoiceActive) { // Ensure there's an active instance
                recognition.stop();
            }
            isVoiceActive = false;
            addConsoleLog('üé§ Voice recognition DEACTIVATED.');
            const voiceButton = document.querySelector('.btn[onclick="toggleVoiceRecognition()"]');
            if (voiceButton) {
                voiceButton.textContent = 'üé§ VOICE';
                voiceButton.classList.remove('btn-listening');
            }
        }

        // Keystroke tracking for WPM
        function setupKeystrokeTracking() {
            document.addEventListener('keydown', () => {
                keystrokeCount++;
            });
            setInterval(updateKeystrokeSpeed, 5000); // Update WPM every 5 seconds
        }

        function updateKeystrokeSpeed() {
            const elapsedTime = (Date.now() - keystrokeStartTime) / 1000 / 60; // in minutes
            if (elapsedTime > 0) {
                const wpm = Math.round(keystrokeCount / 5 / elapsedTime); // 5 characters per word
                document.getElementById('keystrokeSpeed').textContent = wpm;
            } else {
                document.getElementById('keystrokeSpeed').textContent = 0;
            }
            keystrokeCount = 0; // Reset for the next interval
            keystrokeStartTime = Date.now();
        }

        // Control Functions
        function boostFirewall() {
            firewallLevel = 100;
            document.getElementById('firewallLevel').textContent = `${firewallLevel}%`;
            addConsoleLog('üõ°Ô∏è Firewall boosted to 100%. Optimal protection level.', 'success');
            addAIMessage('Firewall reinforced. Protection at maximum. All security protocols are active.');
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear **ALL** chat history and console logs? This action is irreversible.')) {
                chatHistory = [];
                systemLogs = [];
                threatsBlocked = 0;
                localStorage.removeItem('nexusChatHistory');
                localStorage.removeItem('nexusSystemLogs');
                localStorage.removeItem('nexusThreatsBlocked');
                
                document.getElementById('chatMessages').innerHTML = ''; // Clear visually
                document.getElementById('consoleOutput').innerHTML = ''; // Clear visually
                addConsoleLog('üóëÔ∏è All history and logs have been cleared from the system.', 'info');
                addAIMessage('Operation history cleared. Resetting systems.');
                updateSystemStats(); // Update threat counter
            }
        }

        function triggerRedAlert() {
            redAlertActive = !redAlertActive;
            const body = document.body;
            body.classList.toggle('red-alert', redAlertActive);

            if (redAlertActive) {
                addConsoleLog('üö® CRITICAL WARNING! RED ALERT MODE ACTIVATED. Imminent threat detected.', 'error');
                // You can add a sound here if you have one:
                // new Audio('path/to/alarm.mp3').play(); 
                addAIMessage('RED ALERT ACTIVATED! Preparing critical defenses. Tracing intrusion origin...');
            } else {
                addConsoleLog('‚úÖ Red Alert Mode DEACTIVATED. Normalizing security systems.', 'info');
                addAIMessage('Red Alert Mode deactivated. Threat contained. Systems returning to normal.');
            }

            // Automatically deactivate after a time if not manually reactivated
            if (redAlertActive) {
                setTimeout(() => {
                    if (redAlertActive) { // Only deactivates if still active
                        triggerRedAlert(); // Call it again to deactivate
                    }
                }, 15000); // Deactivates after 15 seconds if no new threats or intervention
            }
        }

        // Data persistence with localStorage
        function loadHistory() {
            const savedChat = localStorage.getItem('nexusChatHistory');
            const savedLogs = localStorage.getItem('nexusSystemLogs');
            const savedThreats = localStorage.getItem('nexusThreatsBlocked');

            if (savedChat) {
                chatHistory = JSON.parse(savedChat);
            }
            if (savedLogs) {
                systemLogs = JSON.parse(savedLogs);
                const consoleOutput = document.getElementById('consoleOutput');
                // Load only the last 50 to avoid overcrowding
                systemLogs.slice(-50).forEach(log => {
                    const line = document.createElement('div');
                    line.className = 'console-line';
                    let color = '';
                    if (log.type === 'error') color = '#ff3333';
                    else if (log.type === 'warning') color = '#ff6b00';
                    else color = '#00ffff';
                    line.innerHTML = `<span style="color: #666;">[${new Date(log.timestamp).toLocaleTimeString('en-US', {hour12: false})}]</span> <span style="color: ${color};">[${log.type.toUpperCase()}]</span> ${log.message}`;
                    consoleOutput.appendChild(line);
                });
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
            if (savedThreats) {
                threatsBlocked = parseInt(savedThreats);
            }
        }

        function saveHistory() {
            localStorage.setItem('nexusChatHistory', JSON.stringify(chatHistory));
            localStorage.setItem('nexusSystemLogs', JSON.stringify(systemLogs));
            localStorage.setItem('nexusThreatsBlocked', threatsBlocked.toString());
        }

    </script>
</body>
</html>
